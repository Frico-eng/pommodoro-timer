<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Custom Pomodoro Timer</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --muted:#94a3b8;
    --accent:#ff7a59;
    --glass: rgba(255,255,255,0.03);
    --success:#22c55e;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #081427 100%);color:#e6eef8;display:flex;align-items:center;justify-content:center}
  .card{
    width:min(720px,94vw);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;padding:22px;box-shadow:0 8px 30px rgba(2,6,23,0.6);
    display:grid;grid-template-columns: 1fr 340px;gap:18px;
  }
  @media (max-width:820px){ .card{grid-template-columns:1fr} }
  header{grid-column:1 / -1;display:flex;align-items:center;justify-content:space-between;gap:10px}
  h1{font-size:1.2rem;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;padding:10px 12px;border-radius:10px;color:#081427;font-weight:600;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
  button.ghost{background:transparent;color:var(--muted);border-radius:8px;padding:8px}
  .timer{
    display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;border-radius:12px;background:var(--glass);
    min-height:220px;
    position: relative;
    overflow: hidden;
  }
  .timer.flashing {
    animation: flash 1s ease-in-out 3;
  }
  @keyframes flash {
    0%, 100% { background-color: var(--glass); }
    50% { background-color: rgba(255, 122, 89, 0.2); }
  }
  .bigtime{font-size:4rem;font-weight:700;letter-spacing: -3px}
  .label{margin-top:6px;color:var(--muted)}
  .progress-wrap{width:100%;margin-top:14px}
  progress{appearance:none;width:100%;height:10px;border-radius:999px;overflow:hidden}
  progress::-webkit-progress-bar{background:rgba(255,255,255,0.03)}
  progress::-webkit-progress-value{background:linear-gradient(90deg,var(--accent),#ffb199)}
  .settings{
    padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    display:flex;flex-direction:column;gap:12px;
    height:100%;
  }
  label{font-size:.85rem;color:var(--muted);display:flex;flex-direction:column;gap:6px}
  input[type=number], select{padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .row{display:flex;gap:10px}
  .row > *{flex:1}
  .footer{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:.85rem;padding-top:6px}
  .cycles{font-weight:600;color:var(--success)}
  small.hint{color:var(--muted)}
  .stack{display:flex;flex-direction:column;gap:8px}
  .muted{color:var(--muted)}
  .kbd{background:rgba(255,255,255,0.03);border-radius:6px;padding:6px 8px;font-size:.8rem}
  
  /* New notification options */
  .notification-options {
    margin-top: 10px;
    padding: 10px;
    background: rgba(255,255,255,0.02);
    border-radius: 8px;
  }
  .notification-options label {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    font-size: 0.8rem;
  }
  .notification-options input[type="checkbox"] {
    margin: 0;
  }
</style>
</head>
<body>
  <main class="card" role="application" aria-label="Custom Pomodoro timer">
    <header>
      <h1>Custom Pomodoro Timer</h1>
      <div class="controls" role="toolbar" aria-label="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <button id="resetBtn" class="ghost">Reset</button>
      </div>
    </header>

    <section class="timer" aria-live="polite">
      <div style="text-align:center">
        <div id="modeLabel" class="label">Ready</div>
        <div id="timeDisplay" class="bigtime" aria-atomic="true">25:00</div>
        <div id="subLabel" class="label muted">0 / 0 cycles</div>
      </div>

      <div class="progress-wrap" aria-hidden="false">
        <progress id="progress" value="0" max="100"></progress>
      </div>

      <div style="margin-top:12px;width:100%;display:flex;gap:8px;justify-content:center">
        <button id="skipBtn" class="secondary">Skip</button>
        <button id="soundBtn" class="ghost">ðŸ”Š Sound On</button>
      </div>
    </section>

    <aside class="settings" aria-label="settings">
      <div class="stack">
        <label>Work length (minutes)
          <input id="workMin" type="number" min="1" max="180" value="25" />
        </label>
        <label>Short break (minutes)
          <input id="shortMin" type="number" min="1" max="60" value="5" />
        </label>
        <label>Long break (minutes)
          <input id="longMin" type="number" min="1" max="120" value="15" />
        </label>
        <div class="row">
          <label>Cycles before long break
            <input id="cyclesBeforeLong" type="number" min="1" max="10" value="4" />
          </label>
          <label>Auto-start next?
            <select id="autoStart">
              <option value="true" selected>Yes</option>
              <option value="false">No</option>
            </select>
          </label>
        </div>
      </div>

      <div class="stack" style="margin-top:auto">
        <label>Notifications
          <select id="notifyPerm">
            <option value="none">None</option>
            <option value="browser">Browser (permission required)</option>
            <option value="both">Browser + Sound</option>
            <option value="tab">Tab Flashing</option>
            <option value="all">All Notifications</option>
          </select>
        </label>
        
        <div class="notification-options">
          <label>
            <input type="checkbox" id="tabFlashEnabled" checked>
            Flash browser tab when timer ends
          </label>
          <label>
            <input type="checkbox" id="focusAlertEnabled" checked>
            Alert even when tab is not focused
          </label>
        </div>

        <div style="display:flex;gap:8px;justify-content:space-between;align-items:center">
          <div class="muted">Shortcuts: <span class="kbd">Space</span> start/pause <span class="kbd">R</span> reset</div>
          <button id="saveBtn" class="secondary">Save</button>
        </div>
      </div>
    </aside>

    <div class="footer">
      <div><small class="hint">Auto-saved settings in browser</small></div>
      <div class="muted">Cycles completed <span id="completedCycles" class="cycles">0</span></div>
    </div>
  </main>

<script>
/* ---- Pomodoro logic ---- */
(() => {
  // Elements
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const skipBtn = document.getElementById('skipBtn');
  const soundBtn = document.getElementById('soundBtn');
  const saveBtn = document.getElementById('saveBtn');
  const timerEl = document.querySelector('.timer');
  const tabFlashEnabled = document.getElementById('tabFlashEnabled');
  const focusAlertEnabled = document.getElementById('focusAlertEnabled');

  const workMin = document.getElementById('workMin');
  const shortMin = document.getElementById('shortMin');
  const longMin = document.getElementById('longMin');
  const cyclesBeforeLong = document.getElementById('cyclesBeforeLong');
  const autoStart = document.getElementById('autoStart');
  const notifyPerm = document.getElementById('notifyPerm');

  const timeDisplay = document.getElementById('timeDisplay');
  const modeLabel = document.getElementById('modeLabel');
  const subLabel = document.getElementById('subLabel');
  const progressEl = document.getElementById('progress');
  const completedCyclesEl = document.getElementById('completedCycles');

  // State
  let state = {
    mode: 'work', // 'work' | 'short' | 'long' | 'paused' | 'stopped'
    running: false,
    remaining: 25 * 60,
    intervalId: null,
    cycleCount: 0,
    completedCycles: 0,
    soundOn: true,
    tabFlashInterval: null,
    originalTitle: document.title
  };

  // Tab notification variables
  let isFlashing = false;
  let flashCount = 0;
  const maxFlashCount = 20; // Flash for 20 cycles then stop

  // Tab flashing functionality
  function startTabFlash() {
    if (!tabFlashEnabled.checked) return;
    
    isFlashing = true;
    flashCount = 0;
    const messages = [
      "â° Timer Finished!",
      "Time's Up! â°"
    ];
    let messageIndex = 0;
    
    state.tabFlashInterval = setInterval(() => {
      if (flashCount >= maxFlashCount) {
        stopTabFlash();
        return;
      }
      
      document.title = messages[messageIndex];
      messageIndex = (messageIndex + 1) % messages.length;
      flashCount++;
    }, 800);
  }

  function stopTabFlash() {
    isFlashing = false;
    if (state.tabFlashInterval) {
      clearInterval(state.tabFlashInterval);
      state.tabFlashInterval = null;
    }
    document.title = state.originalTitle;
  }

  // Reset tab title when page becomes visible again
  document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible' && !isFlashing) {
      document.title = state.originalTitle;
    }
  });

  // load/save settings
  const STORAGE_KEY = 'custom_pomodoro_settings_v1';
  function loadSettings(){
    try{
      const stored = JSON.parse(localStorage.getItem(STORAGE_KEY));
      if(stored){
        workMin.value = stored.workMin || 25;
        shortMin.value = stored.shortMin || 5;
        longMin.value = stored.longMin || 15;
        cyclesBeforeLong.value = stored.cyclesBeforeLong || 4;
        autoStart.value = stored.autoStart ?? 'true';
        notifyPerm.value = stored.notifyPerm ?? 'none';
        state.completedCycles = stored.completedCycles || 0;
        tabFlashEnabled.checked = stored.tabFlashEnabled !== false;
        focusAlertEnabled.checked = stored.focusAlertEnabled !== false;
        completedCyclesEl.textContent = state.completedCycles;
      }
    }catch(e){}
    applyDurationsToState();
  }
  function saveSettings(){
    const payload = {
      workMin: Number(workMin.value),
      shortMin: Number(shortMin.value),
      longMin: Number(longMin.value),
      cyclesBeforeLong: Number(cyclesBeforeLong.value),
      autoStart: autoStart.value,
      notifyPerm: notifyPerm.value,
      completedCycles: state.completedCycles,
      tabFlashEnabled: tabFlashEnabled.checked,
      focusAlertEnabled: focusAlertEnabled.checked
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    flashSave();
  }
  function flashSave(){
    saveBtn.textContent = 'Saved';
    setTimeout(()=> saveBtn.textContent = 'Save', 900);
  }

  // durations helper
  function applyDurationsToState(){
    const mins = Number(workMin.value) || 25;
    state.durations = {
      work: mins * 60,
      short: (Number(shortMin.value) || 5) * 60,
      long: (Number(longMin.value) || 15) * 60,
    };
    if(!state.running){
      state.mode = 'work';
      state.remaining = state.durations.work;
      render();
    }
  }

  // rendering
  function fmt(seconds){
    const m = Math.floor(seconds/60);
    const s = seconds % 60;
    return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
  }
  function render(){
    timeDisplay.textContent = fmt(state.remaining);
    modeLabel.textContent = (state.mode === 'work') ? 'Work' : (state.mode === 'short') ? 'Short break' : (state.mode === 'long') ? 'Long break' : 'Paused';
    subLabel.textContent = `${state.cycleCount} / ${cyclesBeforeLong.value} cycles`;
    progressEl.max = state.durations[state.mode] || state.durations.work;
    progressEl.value = progressEl.max - state.remaining;
    completedCyclesEl.textContent = state.completedCycles;
    soundBtn.textContent = state.soundOn ? 'ðŸ”Š Sound On' : 'ðŸ”ˆ Sound Off';
    startBtn.disabled = state.running;
    pauseBtn.disabled = !state.running;
  }

  // timer tick
  function tick(){
    if(state.remaining > 0){
      state.remaining--;
      render();
      return;
    }
    // ended
    handlePeriodEnd();
  }

  function handlePeriodEnd(){
    // Stop any existing tab flash
    stopTabFlash();
    
    // Only alert if tab is focused OR if focusAlert is enabled
    if (document.hasFocus() || focusAlertEnabled.checked) {
      // beep and notify
      if(state.soundOn) beep();
      // Add visual feedback
      timerEl.classList.add('flashing');
      setTimeout(() => timerEl.classList.remove('flashing'), 3000);
      
      // Start tab flashing notification
      startTabFlash();
      
      maybeNotify(`${capitalize(state.mode)} ended`, getEndMessage());
    }
    
    if(state.mode === 'work'){
      state.completedCycles++;
      state.cycleCount++;
    }
    // decide next mode
    if(state.mode === 'work'){
      const shouldLong = state.cycleCount >= Number(cyclesBeforeLong.value);
      if(shouldLong){
        state.mode = 'long';
        state.remaining = state.durations.long;
        state.cycleCount = 0; // reset cycle count after long break
      } else {
        state.mode = 'short';
        state.remaining = state.durations.short;
      }
    } else {
      // break ended -> go to work
      state.mode = 'work';
      state.remaining = state.durations.work;
    }
    saveSettings(); // persist completed cycles
    render();
    // auto-start logic
    if(autoStart.value === 'true'){
      start();
    } else {
      pause();
    }
  }

  function getEndMessage(){
    if(state.mode === 'work') return 'Take a break';
    if(state.mode === 'short') return 'Back to work soon';
    if(state.mode === 'long') return 'Long break over, back to work';
    return '';
  }

  // controls
  function start(){
    if(state.running) return;
    state.running = true;
    state.intervalId = setInterval(tick, 1000);
    render();
    // Stop any flashing when timer starts
    stopTabFlash();
  }
  function pause(){
    state.running = false;
    if(state.intervalId) clearInterval(state.intervalId);
    state.intervalId = null;
    render();
  }
  function reset(){
    pause();
    state.mode = 'work';
    state.cycleCount = 0;
    applyDurationsToState();
    render();
    // Stop any flashing when timer resets
    stopTabFlash();
    // keep completed cycles count
  }
  function skip(){
    // skip to next period immediately
    state.remaining = 0;
    render();
    tick(); // force handlePeriodEnd
  }

  // small utilities
  function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }

  // sound: longer and more noticeable beep with Web Audio API
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    // Resume audio context if it's suspended (needed in Chrome/Firefox)
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }
  }

  function beep() {
    try {
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = 880; // Hz
      g.gain.value = 0.1;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      
      // Create a more noticeable pattern: three beeps with pauses
      o.stop(audioCtx.currentTime + 0.3);
      
      // Add two more beeps after short pauses
      setTimeout(() => {
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = "sine";
        o2.frequency.value = 880;
        g2.gain.value = 0.1;
        o2.connect(g2);
        g2.connect(audioCtx.destination);
        o2.start();
        o2.stop(audioCtx.currentTime + 0.3);
      }, 500);
      
      setTimeout(() => {
        const o3 = audioCtx.createOscillator();
        const g3 = audioCtx.createGain();
        o3.type = "sine";
        o3.frequency.value = 880;
        g3.gain.value = 0.1;
        o3.connect(g3);
        g3.connect(audioCtx.destination);
        o3.start();
        o3.stop(audioCtx.currentTime + 0.3);
      }, 1000);
      
    } catch (e) {
      console.warn("Beep failed:", e);
    }
  }

  // Notifications
  function maybeNotify(title, body){
    const pref = notifyPerm.value;
    if(pref === 'browser' || pref === 'both' || pref === 'all'){
      if(window.Notification && Notification.permission === 'granted'){
        new Notification(title, {body});
      }
    }
    // sound handled elsewhere
  }
  async function requestNotificationPermission(){
    if(!('Notification' in window)) return;
    if(Notification.permission === 'default'){
      try{
        await Notification.requestPermission();
      }catch(e){}
    }
  }

  // events
  startBtn.addEventListener('click', ()=> {
    start();
  });
  pauseBtn.addEventListener('click', ()=> {
    pause();
  });
  resetBtn.addEventListener('click', ()=> {
    reset();
  });
  skipBtn.addEventListener('click', ()=> {
    skip();
  });

  soundBtn.addEventListener('click', ()=>{
    state.soundOn = !state.soundOn;
    render();
  });

  [workMin, shortMin, longMin, cyclesBeforeLong, autoStart].forEach(el => {
    el.addEventListener('change', ()=>{
      applyDurationsToState();
      saveSettings();
    });
  });

  [tabFlashEnabled, focusAlertEnabled].forEach(el => {
    el.addEventListener('change', saveSettings);
  });

  saveBtn.addEventListener('click', saveSettings);
  notifyPerm.addEventListener('change', async ()=>{
    if(notifyPerm.value === 'browser' || notifyPerm.value === 'both' || notifyPerm.value === 'all'){
      await requestNotificationPermission();
      if(Notification.permission !== 'granted'){
        alert('Browser notification permission denied or blocked. Change browser permissions to enable.');
      }
    }
    saveSettings();
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (ev) => {
    if(ev.code === 'Space'){
      ev.preventDefault();
      state.running ? pause() : start();
    } else if(ev.key.toLowerCase() === 'r'){
      reset();
    } else if(ev.key.toLowerCase() === 's'){
      saveSettings();
    }
  });

  // save on unload
  window.addEventListener('beforeunload', saveSettings);

  // initialize
  loadSettings();
  applyDurationsToState();
  render();

  // Store original page title
  state.originalTitle = document.title;

  // expose a tiny API for dev console
  window._pomodoro = {
    start, pause, reset, skip, state,
  };
})();
</script>
</body>
</html>